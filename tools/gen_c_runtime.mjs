// this will generate a stub for the native C runtime from the API definition

import j from '../interface.json' assert { type: 'json' }

const { cart, host }  = j

const typeMap = {
  u32: 'uint32_t',
  u16: 'uint16_t',
  u8: 'uint8_t',
  f64: 'double',
  i16: 'int16_t'
}

function cType(t, name) {
  if (Array.isArray(t)) {
    return cType(t[0], name) + `[${t.length}]`
  }
  if (t === 'string') {
    return 'char*'
  }
  return typeMap[t]
}

function generateShorthand(i) {
  const f = (i.returns === 'void') ? 'v' : 'i'
  const p = Object.keys(i.params)
  return `${f}(${p.map(() => 'i').join('')})`
}

function wrapImport(i) {
  let out = `
// ${i.comment}
static m3ApiRawFunction (null0_${i.name}) {
`
  if (i.returns !== 'void') {
    out += `  m3ApiReturnType (${cType(i.returns)});\n  ${cType(i.returns, 'out')} retval;\n`
  }

  for (const p of Object.keys(i.params)) {
    if (i.params[p] === 'string') {
      out += `  m3ApiGetArgMem(const char*, _s${p});\n  char ${p}[1024];\n  null0_string(_s${p}, ${p});`
    } else {
      out += `  m3ApiGetArg(${cType(i.params[p])}, ${p});`
    }
    out += '\n'
  }

  out+= '\n  // CODE GOES HERE\n\n'

  if (i.returns === 'void') {
    out += '  m3ApiSuccess();\n'
  } else {
    out += '  m3ApiSuccess(retval);\n'
  }

  out += `}\n`
  return out
}

const code = `
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "wasm3.h"
#include "m3_env.h"

static M3Environment* env;
static M3Runtime* runtime;
static M3Module* module;

// throw a fatal error
static void null0_fatal_error(char* func, char* msg) {
  fprintf(stderr, "FATAL: %s - %s\\n", func, msg);
  exit(1);
}

// all wasm3 functions return same sort of error-pattern, so this wraps that
static void null0_check_wasm3 (M3Result result) {
  if (result) {
    M3ErrorInfo info;
    m3_GetErrorInfo(runtime, &info);
    char *message;
    sprintf(message, "%s - %s", result, info.message);
    null0_fatal_error("wasm", message);
  }
}

// this checks the general state of the runtime, to make sure there are no errors lingering
static void null0_check_wasm3_is_ok () {
  M3ErrorInfo error;
  m3_GetErrorInfo(runtime, &error);
  if (error.result) {
    char *message;
    sprintf(message, "%s - %s", error.result, error.message);
    null0_fatal_error("wasm", message);
  }
}

// helper similar to code generated by assemblyscript for pulling a string from a pointer
void null0_string(const char* str, char* out) {
  int i;
  for (i = 0; i < sizeof(out); i+=2) {
    out[i/2] =  *( str + i );
  }
  out[(i/2) + 1] = '\0';
}

// IMPORTS
${host.filter(i => !i.internal).map(i => wrapImport(i)).join('\n')}

// EXPORTS
${cart.map(e => `static M3Function* cart_${e.name}`).join('\n')}

// load a wasm binary buffer
void null0_load_cart_wasm (u8* wasmBuffer, int byteLength) {
  env = m3_NewEnvironment();
  runtime = m3_NewRuntime (env, 1024, NULL);
  null0_check_wasm3(m3_ParseModule (env, &module, wasmBuffer, byteLength));
  null0_check_wasm3(m3_LoadModule(runtime, module));

  // IMPORTS
${host.filter(i => !i.internal).map(i => `  m3_LinkRawFunction(module, "env", "null0_${i.name}", "${generateShorthand(i)}", &null0_${i.name});`).join('\n')}
  
  null0_check_wasm3_is_ok();

  // EXPORTS
${cart.map(e => `  m3_FindFunction(&cart_${e.name}, runtime, "${e.name}");`).join('\n')}
}

// load a binary wasm file
void null0_load_cart_file (char* filename) {
  u8* wasm = NULL;
  int fsize = 0;
  
  FILE* f = fopen (filename, "rb");
  if (!f) null0_fatal_error("file", "open - Cannot open file.");
  fseek (f, 0, SEEK_END);
  fsize = ftell(f);
  fseek (f, 0, SEEK_SET);

  if (fsize < 8) {
    null0_fatal_error("file", "size - File is too small.");
  } else if (fsize > 64*1024*1024) {
    null0_fatal_error("file", "size - File is too big.");
  }

  wasm = (u8*) malloc(fsize);
  if (!wasm) {
    null0_fatal_error("file", "memory - Cannot allocate memory for wasm binary.");
  }

  if (fread (wasm, 1, fsize, f) != fsize) {
    null0_fatal_error("file", "read - Cannot read file.");
  }
  fclose (f);
  f = NULL;

  null0_load_cart_wasm(wasm, fsize);
}

int main (int argc, char **argv) {
  null0_load_cart_file(argv[1]);
  
  if (cart_init) {
    null0_check_wasm3(m3_CallV(cart_init));
  } else {
    null0_fatal_error("cart", "no init!");
  }

  return 0;
}
`

console.log(code)
